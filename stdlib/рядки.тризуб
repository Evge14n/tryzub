// Стандартна бібліотека мови Тризуб
// Модуль: рядки

модуль рядки {
    // Функції для роботи з рядками
    
    публічний функція довжина(рядок: тхт) -> цл64 {
        зовнішня функція strlen(s: тхт) -> цл64
        повернути strlen(рядок)
    }
    
    публічний функція порожній(рядок: тхт) -> лог {
        повернути довжина(рядок) == 0
    }
    
    публічний функція об'єднати(а: тхт, б: тхт) -> тхт {
        зовнішня функція strcat(dest: тхт, src: тхт) -> тхт
        повернути strcat(а, б)
    }
    
    публічний функція порівняти(а: тхт, б: тхт) -> цл32 {
        зовнішня функція strcmp(s1: тхт, s2: тхт) -> цл32
        повернути strcmp(а, б)
    }
    
    публічний функція однакові(а: тхт, б: тхт) -> лог {
        повернути порівняти(а, б) == 0
    }
    
    публічний функція копіювати(джерело: тхт) -> тхт {
        зовнішня функція strdup(s: тхт) -> тхт
        повернути strdup(джерело)
    }
    
    публічний функція підрядок(рядок: тхт, початок: цл64, кінець: цл64) -> тхт {
        змінна довжина_рядка = довжина(рядок)
        
        якщо (початок < 0 || початок >= довжина_рядка) {
            повернути ""
        }
        
        якщо (кінець > довжина_рядка) {
            кінець = довжина_рядка
        }
        
        якщо (початок >= кінець) {
            повернути ""
        }
        
        змінна результат = новий_рядок(кінець - початок)
        для (i від 0 до кінець - початок) {
            результат[i] = рядок[початок + i]
        }
        
        повернути результат
    }
    
    публічний функція знайти(рядок: тхт, підрядок: тхт) -> цл64 {
        зовнішня функція strstr(haystack: тхт, needle: тхт) -> тхт
        
        змінна знайдено = strstr(рядок, підрядок)
        якщо (знайдено == нуль) {
            повернути -1
        }
        
        // Обчислюємо індекс
        повернути знайдено - рядок
    }
    
    публічний функція містить(рядок: тхт, підрядок: тхт) -> лог {
        повернути знайти(рядок, підрядок) != -1
    }
    
    публічний функція починається_з(рядок: тхт, префікс: тхт) -> лог {
        змінна довжина_префікса = довжина(префікс)
        якщо (довжина_префікса > довжина(рядок)) {
            повернути хиба
        }
        
        для (i від 0 до довжина_префікса) {
            якщо (рядок[i] != префікс[i]) {
                повернути хиба
            }
        }
        
        повернути істина
    }
    
    публічний функція закінчується_на(рядок: тхт, суфікс: тхт) -> лог {
        змінна довжина_рядка = довжина(рядок)
        змінна довжина_суфікса = довжина(суфікс)
        
        якщо (довжина_суфікса > довжина_рядка) {
            повернути хиба
        }
        
        змінна початок = довжина_рядка - довжина_суфікса
        для (i від 0 до довжина_суфікса) {
            якщо (рядок[початок + i] != суфікс[i]) {
                повернути хиба
            }
        }
        
        повернути істина
    }
    
    публічний функція замінити(рядок: тхт, старий: тхт, новий: тхт) -> тхт {
        змінна результат = ""
        змінна позиція = 0
        змінна довжина_старого = довжина(старий)
        
        поки (позиція < довжина(рядок)) {
            змінна індекс = знайти(підрядок(рядок, позиція, довжина(рядок)), старий)
            
            якщо (індекс == -1) {
                результат = об'єднати(результат, підрядок(рядок, позиція, довжина(рядок)))
                переривати
            }
            
            результат = об'єднати(результат, підрядок(рядок, позиція, позиція + індекс))
            результат = об'єднати(результат, новий)
            позиція = позиція + індекс + довжина_старого
        }
        
        повернути результат
    }
    
    публічний функція розділити(рядок: тхт, роздільник: тхт) -> [тхт] {
        змінна результат: [тхт] = []
        змінна позиція = 0
        змінна довжина_роздільника = довжина(роздільник)
        
        якщо (довжина_роздільника == 0) {
            додати(результат, рядок)
            повернути результат
        }
        
        поки (позиція < довжина(рядок)) {
            змінна індекс = знайти(підрядок(рядок, позиція, довжина(рядок)), роздільник)
            
            якщо (індекс == -1) {
                додати(результат, підрядок(рядок, позиція, довжина(рядок)))
                переривати
            }
            
            додати(результат, підрядок(рядок, позиція, позиція + індекс))
            позиція = позиція + індекс + довжина_роздільника
        }
        
        повернути результат
    }
    
    публічний функція з'єднати(рядки: [тхт], роздільник: тхт) -> тхт {
        якщо (довжина(рядки) == 0) {
            повернути ""
        }
        
        змінна результат = рядки[0]
        
        для (i від 1 до довжина(рядки)) {
            результат = об'єднати(результат, роздільник)
            результат = об'єднати(результат, рядки[i])
        }
        
        повернути результат
    }
    
    публічний функція обрізати(рядок: тхт) -> тхт {
        змінна початок = 0
        змінна кінець = довжина(рядок)
        
        // Пропускаємо пробіли на початку
        поки (початок < кінець && є_пробілом(рядок[початок])) {
            початок += 1
        }
        
        // Пропускаємо пробіли в кінці
        поки (кінець > початок && є_пробілом(рядок[кінець - 1])) {
            кінець -= 1
        }
        
        повернути підрядок(рядок, початок, кінець)
    }
    
    публічний функція до_верхнього(рядок: тхт) -> тхт {
        змінна результат = копіювати(рядок)
        
        для (i від 0 до довжина(результат)) {
            якщо (результат[i] >= 'а' && результат[i] <= 'я') {
                результат[i] = результат[i] - 32
            } інакше якщо (результат[i] >= 'ґ' && результат[i] <= 'ї') {
                // Обробка українських літер
                результат[i] = до_верхнього_укр(результат[i])
            }
        }
        
        повернути результат
    }
    
    публічний функція до_нижнього(рядок: тхт) -> тхт {
        змінна результат = копіювати(рядок)
        
        для (i від 0 до довжина(результат)) {
            якщо (результат[i] >= 'А' && результат[i] <= 'Я') {
                результат[i] = результат[i] + 32
            } інакше якщо (результат[i] >= 'Ґ' && результат[i] <= 'Ї') {
                // Обробка українських літер
                результат[i] = до_нижнього_укр(результат[i])
            }
        }
        
        повернути результат
    }
    
    публічний функція є_цифрою(символ: сим) -> лог {
        повернути символ >= '0' && символ <= '9'
    }
    
    публічний функція є_літерою(символ: сим) -> лог {
        повернути (символ >= 'а' && символ <= 'я') ||
                 (символ >= 'А' && символ <= 'Я') ||
                 є_українською_літерою(символ)
    }
    
    публічний функція є_пробілом(символ: сим) -> лог {
        повернути символ == ' ' || символ == '\t' || 
                 символ == '\n' || символ == '\r'
    }
    
    приватний функція є_українською_літерою(символ: сим) -> лог {
        // Перевірка українських літер
        повернути (символ >= 'а' && символ <= 'я') ||
                 (символ >= 'А' && символ <= 'Я') ||
                 символ == 'ґ' || символ == 'Ґ' ||
                 символ == 'є' || символ == 'Є' ||
                 символ == 'і' || символ == 'І' ||
                 символ == 'ї' || символ == 'Ї'
    }
    
    приватний функція до_верхнього_укр(символ: сим) -> сим {
        якщо (символ == 'ґ') повернути 'Ґ'
        якщо (символ == 'є') повернути 'Є'
        якщо (символ == 'і') повернути 'І'
        якщо (символ == 'ї') повернути 'Ї'
        повернути символ
    }
    
    приватний функція до_нижнього_укр(символ: сим) -> сим {
        якщо (символ == 'Ґ') повернути 'ґ'
        якщо (символ == 'Є') повернути 'є'
        якщо (символ == 'І') повернути 'і'
        якщо (символ == 'Ї') повернути 'ї'
        повернути символ
    }
    
    // Форматування рядків
    публічний функція форматувати(шаблон: тхт, аргументи: ...) -> тхт {
        зовнішня функція sprintf(buffer: тхт, format: тхт, ...) -> цл32
        
        змінна буфер = новий_рядок(1024)
        sprintf(буфер, шаблон, аргументи)
        повернути буфер
    }
    
    // Конвертація типів
    публічний функція ціле_в_рядок(число: цл64) -> тхт {
        повернути форматувати("%d", число)
    }
    
    публічний функція дробове_в_рядок(число: дрб64) -> тхт {
        повернути форматувати("%f", число)
    }
    
    публічний функція рядок_в_ціле(рядок: тхт) -> цл64 {
        зовнішня функція atol(s: тхт) -> цл64
        повернути atol(рядок)
    }
    
    публічний функція рядок_в_дробове(рядок: тхт) -> дрб64 {
        зовнішня функція atof(s: тхт) -> дрб64
        повернути atof(рядок)
    }
    
    // Пошук за шаблоном
    публічний функція відповідає_шаблону(рядок: тхт, шаблон: тхт) -> лог {
        // Простий шаблон з * та ?
        змінна i = 0
        змінна j = 0
        змінна довжина_рядка = довжина(рядок)
        змінна довжина_шаблону = довжина(шаблон)
        
        поки (i < довжина_рядка && j < довжина_шаблону) {
            якщо (шаблон[j] == '*') {
                // Пропускаємо будь-яку кількість символів
                j += 1
                якщо (j == довжина_шаблону) {
                    повернути істина
                }
                
                поки (i < довжина_рядка) {
                    якщо (відповідає_шаблону(підрядок(рядок, i, довжина_рядка), 
                                            підрядок(шаблон, j, довжина_шаблону))) {
                        повернути істина
                    }
                    i += 1
                }
                повернути хиба
            } інакше якщо (шаблон[j] == '?') {
                // Відповідає будь-якому одному символу
                i += 1
                j += 1
            } інакше {
                // Символи мають збігатися
                якщо (рядок[i] != шаблон[j]) {
                    повернути хиба
                }
                i += 1
                j += 1
            }
        }
        
        // Перевіряємо, чи дійшли до кінця обох рядків
        поки (j < довжина_шаблону && шаблон[j] == '*') {
            j += 1
        }
        
        повернути i == довжина_рядка && j == довжина_шаблону
    }
}
