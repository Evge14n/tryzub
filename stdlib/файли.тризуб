// Стандартна бібліотека мови Тризуб
// Модуль: файли

модуль файли {
    // Режими відкриття файлів
    публічний стала ЧИТАННЯ: тхт = "r"
    публічний стала ЗАПИС: тхт = "w"
    публічний стала ДОДАВАННЯ: тхт = "a"
    публічний стала ЧИТАННЯ_ЗАПИС: тхт = "r+"
    публічний стала БІНАРНЕ_ЧИТАННЯ: тхт = "rb"
    публічний стала БІНАРНИЙ_ЗАПИС: тхт = "wb"
    
    // Тип для представлення файлу
    публічний структура Файл {
        приватний дескриптор: покажчик
        приватний шлях: тхт
        приватний режим: тхт
        приватний відкритий: лог
    }
    
    // Функції для роботи з файлами
    публічний функція відкрити(шлях: тхт, режим: тхт) -> Файл {
        зовнішня функція fopen(filename: тхт, mode: тхт) -> покажчик
        
        змінна дескриптор = fopen(шлях, режим)
        якщо (дескриптор == нуль) {
            помилка("Не вдалося відкрити файл: " + шлях)
        }
        
        повернути Файл {
            дескриптор: дескриптор,
            шлях: шлях,
            режим: режим,
            відкритий: істина
        }
    }
    
    публічний функція закрити(файл: &Файл) {
        зовнішня функція fclose(file: покажчик) -> цл32
        
        якщо (файл.відкритий) {
            fclose(файл.дескриптор)
            файл.відкритий = хиба
        }
    }
    
    публічний функція читати(файл: &Файл, розмір: цл64) -> тхт {
        зовнішня функція fread(buffer: покажчик, size: цл64, count: цл64, stream: покажчик) -> цл64
        
        якщо (!файл.відкритий) {
            помилка("Файл не відкритий")
        }
        
        змінна буфер = новий_буфер(розмір + 1)
        змінна прочитано = fread(буфер, 1, розмір, файл.дескриптор)
        буфер[прочитано] = '\0'
        
        повернути буфер як тхт
    }
    
    публічний функція читати_рядок(файл: &Файл) -> тхт {
        зовнішня функція fgets(buffer: покажчик, size: цл32, stream: покажчик) -> покажчик
        
        якщо (!файл.відкритий) {
            помилка("Файл не відкритий")
        }
        
        змінна буфер = новий_буфер(1024)
        змінна результат = fgets(буфер, 1024, файл.дескриптор)
        
        якщо (результат == нуль) {
            повернути ""
        }
        
        повернути буфер як тхт
    }
    
    публічний функція читати_весь(файл: &Файл) -> тхт {
        якщо (!файл.відкритий) {
            помилка("Файл не відкритий")
        }
        
        // Отримуємо розмір файлу
        змінна розмір = розмір_файлу(файл)
        
        // Повертаємось на початок
        перейти_на_початок(файл)
        
        // Читаємо весь файл
        повернути читати(файл, розмір)
    }
    
    публічний функція писати(файл: &Файл, дані: тхт) -> цл64 {
        зовнішня функція fwrite(data: покажчик, size: цл64, count: цл64, stream: покажчик) -> цл64
        
        якщо (!файл.відкритий) {
            помилка("Файл не відкритий")
        }
        
        змінна довжина = довжина(дані)
        повернути fwrite(дані, 1, довжина, файл.дескриптор)
    }
    
    публічний функція писати_рядок(файл: &Файл, рядок: тхт) {
        зовнішня функція fputs(s: тхт, stream: покажчик) -> цл32
        
        якщо (!файл.відкритий) {
            помилка("Файл не відкритий")
        }
        
        fputs(рядок, файл.дескриптор)
    }
    
    публічний функція є_кінцем(файл: &Файл) -> лог {
        зовнішня функція feof(stream: покажчик) -> цл32
        
        якщо (!файл.відкритий) {
            помилка("Файл не відкритий")
        }
        
        повернути feof(файл.дескриптор) != 0
    }
    
    публічний функція розмір_файлу(файл: &Файл) -> цл64 {
        зовнішня функція ftell(stream: покажчик) -> цл64
        зовнішня функція fseek(stream: покажчик, offset: цл64, whence: цл32) -> цл32
        
        якщо (!файл.відкритий) {
            помилка("Файл не відкритий")
        }
        
        змінна поточна_позиція = ftell(файл.дескриптор)
        fseek(файл.дескриптор, 0, 2) // SEEK_END
        змінна розмір = ftell(файл.дескриптор)
        fseek(файл.дескриптор, поточна_позиція, 0) // SEEK_SET
        
        повернути розмір
    }
    
    публічний функція перейти_на_початок(файл: &Файл) {
        зовнішня функція rewind(stream: покажчик)
        
        якщо (!файл.відкритий) {
            помилка("Файл не відкритий")
        }
        
        rewind(файл.дескриптор)
    }
    
    публічний функція перейти_на_позицію(файл: &Файл, позиція: цл64) {
        зовнішня функція fseek(stream: покажчик, offset: цл64, whence: цл32) -> цл32
        
        якщо (!файл.відкритий) {
            помилка("Файл не відкритий")
        }
        
        fseek(файл.дескриптор, позиція, 0) // SEEK_SET
    }
    
    публічний функція отримати_позицію(файл: &Файл) -> цл64 {
        зовнішня функція ftell(stream: покажчик) -> цл64
        
        якщо (!файл.відкритий) {
            помилка("Файл не відкритий")
        }
        
        повернути ftell(файл.дескриптор)
    }
    
    публічний функція очистити_буфер(файл: &Файл) {
        зовнішня функція fflush(stream: покажчик) -> цл32
        
        якщо (!файл.відкритий) {
            помилка("Файл не відкритий")
        }
        
        fflush(файл.дескриптор)
    }
    
    // Функції для роботи з файловою системою
    публічний функція існує(шлях: тхт) -> лог {
        зовнішня функція access(pathname: тхт, mode: цл32) -> цл32
        повернути access(шлях, 0) == 0 // F_OK = 0
    }
    
    публічний функція видалити(шлях: тхт) -> лог {
        зовнішня функція remove(filename: тхт) -> цл32
        повернути remove(шлях) == 0
    }
    
    публічний функція перейменувати(старий_шлях: тхт, новий_шлях: тхт) -> лог {
        зовнішня функція rename(old: тхт, new: тхт) -> цл32
        повернути rename(старий_шлях, новий_шлях) == 0
    }
    
    публічний функція копіювати(джерело: тхт, призначення: тхт) -> лог {
        змінна вхідний = відкрити(джерело, БІНАРНЕ_ЧИТАННЯ)
        змінна вихідний = відкрити(призначення, БІНАРНИЙ_ЗАПИС)
        
        змінна буфер_розмір: цл64 = 4096
        змінна успіх = істина
        
        поки (!є_кінцем(вхідний)) {
            змінна дані = читати(вхідний, буфер_розмір)
            якщо (довжина(дані) > 0) {
                змінна записано = писати(вихідний, дані)
                якщо (записано != довжина(дані)) {
                    успіх = хиба
                    переривати
                }
            }
        }
        
        закрити(вхідний)
        закрити(вихідний)
        
        повернути успіх
    }
    
    публічний функція створити_директорію(шлях: тхт) -> лог {
        зовнішня функція mkdir(pathname: тхт, mode: цл32) -> цл32
        повернути mkdir(шлях, 0755) == 0
    }
    
    публічний функція є_директорією(шлях: тхт) -> лог {
        зовнішня функція is_directory(path: тхт) -> лог
        повернути is_directory(шлях)
    }
    
    публічний функція є_файлом(шлях: тхт) -> лог {
        зовнішня функція is_regular_file(path: тхт) -> лог
        повернути is_regular_file(шлях)
    }
    
    // Допоміжні функції
    публічний функція читати_файл(шлях: тхт) -> тхт {
        змінна файл = відкрити(шлях, ЧИТАННЯ)
        змінна вміст = читати_весь(файл)
        закрити(файл)
        повернути вміст
    }
    
    публічний функція записати_файл(шлях: тхт, вміст: тхт) -> лог {
        спробувати {
            змінна файл = відкрити(шлях, ЗАПИС)
            писати(файл, вміст)
            закрити(файл)
            повернути істина
        } зловити (е) {
            повернути хиба
        }
    }
    
    публічний функція додати_до_файлу(шлях: тхт, вміст: тхт) -> лог {
        спробувати {
            змінна файл = відкрити(шлях, ДОДАВАННЯ)
            писати(файл, вміст)
            закрити(файл)
            повернути істина
        } зловити (е) {
            повернути хиба
        }
    }
    
    публічний функція читати_рядки(шлях: тхт) -> [тхт] {
        змінна файл = відкрити(шлях, ЧИТАННЯ)
        змінна рядки: [тхт] = []
        
        поки (!є_кінцем(файл)) {
            змінна рядок = читати_рядок(файл)
            якщо (довжина(рядок) > 0) {
                // Видаляємо символ нового рядка
                якщо (рядок[довжина(рядок) - 1] == '\n') {
                    рядок = підрядок(рядок, 0, довжина(рядок) - 1)
                }
                додати(рядки, рядок)
            }
        }
        
        закрити(файл)
        повернути рядки
    }
    
    публічний функція записати_рядки(шлях: тхт, рядки: [тхт]) -> лог {
        спробувати {
            змінна файл = відкрити(шлях, ЗАПИС)
            
            для (рядок в рядки) {
                писати_рядок(файл, рядок)
                писати(файл, "\n")
            }
            
            закрити(файл)
            повернути істина
        } зловити (е) {
            повернути хиба
        }
    }
}
