use clap::{Parser, Subcommand};
use anyhow::Result;
use std::path::PathBuf;

// mod lexer;
// mod parser;
// mod compiler;
// mod vm;
// mod runtime;

#[derive(Parser)]
#[command(name = "tryzub")]
#[command(author = "Tryzub Team")]
#[command(version = "0.1.0")]
#[command(about = "–¢—Ä–∏–∑—É–± - –Ω–∞–π—à–≤–∏–¥—à–∞ —É–∫—Ä–∞—ó–Ω–æ–º–æ–≤–Ω–∞ –º–æ–≤–∞ –ø—Ä–æ–≥—Ä–∞–º—É–≤–∞–Ω–Ω—è", long_about = None)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// –ö–æ–º–ø—ñ–ª—é–≤–∞—Ç–∏ —Ñ–∞–π–ª —É –≤–∏–∫–æ–Ω—É–≤–∞–Ω–∏–π —Ñ–∞–π–ª
    –ö–æ–º–ø—ñ–ª—é–≤–∞—Ç–∏ {
        /// –í—Ö—ñ–¥–Ω–∏–π —Ñ–∞–π–ª .—Ç—Ä–∏–∑—É–±
        #[arg(value_name = "–§–ê–ô–õ")]
        –≤—Ö—ñ–¥: PathBuf,
        
        /// –í–∏—Ö—ñ–¥–Ω–∏–π —Ñ–∞–π–ª
        #[arg(short = '–≤', long = "–≤–∏—Ö—ñ–¥")]
        –≤–∏—Ö—ñ–¥: Option<PathBuf>,
        
        /// –†—ñ–≤–µ–Ω—å –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—ó (0-3)
        #[arg(short = '–û', long = "–æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è", default_value = "2")]
        –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è: u8,
        
        /// –¶—ñ–ª—å–æ–≤–∞ –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞
        #[arg(short = '—Ü', long = "—Ü—ñ–ª—å")]
        —Ü—ñ–ª—å: Option<String>,
    },
    
    /// –ó–∞–ø—É—Å—Ç–∏—Ç–∏ —Ñ–∞–π–ª –±–µ–∑ –∫–æ–º–ø—ñ–ª—è—Ü—ñ—ó
    –ó–∞–ø—É—Å—Ç–∏—Ç–∏ {
        /// –§–∞–π–ª –¥–ª—è –∑–∞–ø—É—Å–∫—É
        #[arg(value_name = "–§–ê–ô–õ")]
        —Ñ–∞–π–ª: PathBuf,
        
        /// –ê—Ä–≥—É–º–µ–Ω—Ç–∏ –ø—Ä–æ–≥—Ä–∞–º–∏
        #[arg(trailing_var_arg = true)]
        –∞—Ä–≥—É–º–µ–Ω—Ç–∏: Vec<String>,
    },
    
    /// –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å —Ñ–∞–π–ª—É
    –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ {
        /// –§–∞–π–ª –¥–ª—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏
        #[arg(value_name = "–§–ê–ô–õ")]
        —Ñ–∞–π–ª: PathBuf,
    },
    
    /// –°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–æ–≤–∏–π –ø—Ä–æ–µ–∫—Ç
    –ù–æ–≤–∏–π {
        /// –ù–∞–∑–≤–∞ –ø—Ä–æ–µ–∫—Ç—É
        –Ω–∞–∑–≤–∞: String,
        
        /// –¢–∏–ø –ø—Ä–æ–µ–∫—Ç—É
        #[arg(short = '—Ç', long = "—Ç–∏–ø", default_value = "–ø—Ä–æ–≥—Ä–∞–º–∞")]
        —Ç–∏–ø_–ø—Ä–æ–µ–∫—Ç—É: String,
    },
    
    /// –ó—ñ–±—Ä–∞—Ç–∏ –ø—Ä–æ–µ–∫—Ç
    –ó—ñ–±—Ä–∞—Ç–∏ {
        /// –†–µ–∂–∏–º –∑–±—ñ—Ä–∫–∏
        #[arg(short = '—Ä', long = "—Ä–µ–∂–∏–º", default_value = "–≤–∏–ø—É—Å–∫")]
        —Ä–µ–∂–∏–º: String,
    },
    
    /// –§–æ—Ä–º–∞—Ç—É–≤–∞—Ç–∏ –∫–æ–¥
    –§–æ—Ä–º–∞—Ç—É–≤–∞—Ç–∏ {
        /// –§–∞–π–ª–∏ –¥–ª—è —Ñ–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è
        —Ñ–∞–π–ª–∏: Vec<PathBuf>,
    },
}

// #[global_allocator]
// static GLOBAL: mimalloc::MiMalloc = mimalloc::MiMalloc;

fn main() -> Result<()> {
    let cli = Cli::parse();
    
    match cli.command {
        Commands::–ö–æ–º–ø—ñ–ª—é–≤–∞—Ç–∏ { –≤—Ö—ñ–¥, –≤–∏—Ö—ñ–¥, –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è, —Ü—ñ–ª—å } => {
            println!("–ö–æ–º–ø—ñ–ª—é—é —Ñ–∞–π–ª: {:?}", –≤—Ö—ñ–¥);
            compile_file(–≤—Ö—ñ–¥, –≤–∏—Ö—ñ–¥, –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è, —Ü—ñ–ª—å)?;
        }
        Commands::–ó–∞–ø—É—Å—Ç–∏—Ç–∏ { —Ñ–∞–π–ª, –∞—Ä–≥—É–º–µ–Ω—Ç–∏ } => {
            println!("–ó–∞–ø—É—Å–∫–∞—é —Ñ–∞–π–ª: {:?}", —Ñ–∞–π–ª);
            run_file(—Ñ–∞–π–ª, –∞—Ä–≥—É–º–µ–Ω—Ç–∏)?;
        }
        Commands::–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ { —Ñ–∞–π–ª } => {
            println!("–ü–µ—Ä–µ–≤—ñ—Ä—è—é —Ñ–∞–π–ª: {:?}", —Ñ–∞–π–ª);
            check_file(—Ñ–∞–π–ª)?;
        }
        Commands::–ù–æ–≤–∏–π { –Ω–∞–∑–≤–∞, —Ç–∏–ø_–ø—Ä–æ–µ–∫—Ç—É } => {
            println!("–°—Ç–≤–æ—Ä—é—é –Ω–æ–≤–∏–π –ø—Ä–æ–µ–∫—Ç: {}", –Ω–∞–∑–≤–∞);
            create_project(–Ω–∞–∑–≤–∞, —Ç–∏–ø_–ø—Ä–æ–µ–∫—Ç—É)?;
        }
        Commands::–ó—ñ–±—Ä–∞—Ç–∏ { —Ä–µ–∂–∏–º } => {
            println!("–ó–±–∏—Ä–∞—é –ø—Ä–æ–µ–∫—Ç —É —Ä–µ–∂–∏–º—ñ: {}", —Ä–µ–∂–∏–º);
            build_project(—Ä–µ–∂–∏–º)?;
        }
        Commands::–§–æ—Ä–º–∞—Ç—É–≤–∞—Ç–∏ { —Ñ–∞–π–ª–∏ } => {
            println!("–§–æ—Ä–º–∞—Ç—É—é {} —Ñ–∞–π–ª—ñ–≤", —Ñ–∞–π–ª–∏.len());
            format_files(—Ñ–∞–π–ª–∏)?;
        }
    }
    
    Ok(())
}

fn compile_file(input: PathBuf, output: Option<PathBuf>, opt_level: u8, target: Option<String>) -> Result<()> {
    let source = std::fs::read_to_string(&input)?;
    
    // –õ–µ–∫—Å–∏—á–Ω–∏–π –∞–Ω–∞–ª—ñ–∑
    // TODO: –Ü–º–ø–ª–µ–º–µ–Ω—Ç—É–≤–∞—Ç–∏ –∫–æ–º–ø—ñ–ª—è—Ü—ñ—é
    println!("–ö–æ–º–ø—ñ–ª—è—Ü—ñ—è —â–µ –≤ —Ä–æ–∑—Ä–æ–±—Ü—ñ...");
    
    Ok(())
}

fn run_file(file: PathBuf, args: Vec<String>) -> Result<()> {
    let source = std::fs::read_to_string(&file)?;
    
    // –õ–µ–∫—Å–∏—á–Ω–∏–π –∞–Ω–∞–ª—ñ–∑
    // TODO: –Ü–º–ø–ª–µ–º–µ–Ω—Ç—É–≤–∞—Ç–∏ —ñ–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü—ñ—é
    println!("\nüá∫üá¶ –í—ñ—Ç–∞—î–º–æ –≤ –º–æ–≤—ñ –ø—Ä–æ–≥—Ä–∞–º—É–≤–∞–Ω–Ω—è –¢—Ä–∏–∑—É–±!\n");
    println!("–§–∞–π–ª: {}\n", file.display());
    println!("=== –í–º—ñ—Å—Ç –ø—Ä–æ–≥—Ä–∞–º–∏ ===");
    println!("{}", source);
    println!("=== –ö—ñ–Ω–µ—Ü—å –ø—Ä–æ–≥—Ä–∞–º–∏ ===\n");
    println!("‚úì –ü—Ä–æ–≥—Ä–∞–º–∞ —Å–∏–Ω—Ç–∞–∫—Å–∏—á–Ω–æ –ø—Ä–∞–≤–∏–ª—å–Ω–∞ (–¥–µ–º–æ-—Ä–µ–∂–∏–º)");
    println!("\n–ü—Ä–∏–º—ñ—Ç–∫–∞: –ü–æ–≤–Ω–∞ —ñ–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü—ñ—è –±—É–¥–µ –¥–æ—Å—Ç—É–ø–Ω–∞ –≤ –Ω–∞—Å—Ç—É–ø–Ω—ñ–π –≤–µ—Ä—Å—ñ—ó!");
    
    Ok(())
}

fn check_file(file: PathBuf) -> Result<()> {
    let source = std::fs::read_to_string(&file)?;
    
    // –õ–µ–∫—Å–∏—á–Ω–∏–π –∞–Ω–∞–ª—ñ–∑
    // TODO: –Ü–º–ø–ª–µ–º–µ–Ω—Ç—É–≤–∞—Ç–∏ –ø–µ—Ä–µ–≤—ñ—Ä–∫—É
    println!("–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å—É —â–µ –≤ —Ä–æ–∑—Ä–æ–±—Ü—ñ...");
    Ok(())
}

fn create_project(name: String, project_type: String) -> Result<()> {
    std::fs::create_dir(&name)?;
    std::fs::create_dir(format!("{}/src", name))?;
    
    // –°—Ç–≤–æ—Ä—é—î–º–æ –æ—Å–Ω–æ–≤–Ω–∏–π —Ñ–∞–π–ª
    let main_content = match project_type.as_str() {
        "–ø—Ä–æ–≥—Ä–∞–º–∞" => {
            r#"// –ì–æ–ª–æ–≤–Ω–∞ –ø—Ä–æ–≥—Ä–∞–º–∞
—Ñ—É–Ω–∫—Ü—ñ—è –≥–æ–ª–æ–≤–Ω–∞() {
    –¥—Ä—É–∫("–ü—Ä–∏–≤—ñ—Ç, —Å–≤—ñ—Ç!")
}
"#
        }
        "–±—ñ–±–ª—ñ–æ—Ç–µ–∫–∞" => {
            r#"// –ë—ñ–±–ª—ñ–æ—Ç–µ–∫–∞
–º–æ–¥—É–ª—å –º–æ—è_–±—ñ–±–ª—ñ–æ—Ç–µ–∫–∞ {
    —Ñ—É–Ω–∫—Ü—ñ—è –ø—Ä–∏–≤—ñ—Ç–∞–Ω–Ω—è(—ñ–º'—è: —Ç—Ö—Ç) {
        –¥—Ä—É–∫("–ü—Ä–∏–≤—ñ—Ç, " + —ñ–º'—è + "!")
    }
}
"#
        }
        _ => return Err(anyhow::anyhow!("–ù–µ–≤—ñ–¥–æ–º–∏–π —Ç–∏–ø –ø—Ä–æ–µ–∫—Ç—É")),
    };
    
    std::fs::write(format!("{}/src/–≥–æ–ª–æ–≤–Ω–∞.—Ç—Ä–∏–∑—É–±", name), main_content)?;
    
    // –°—Ç–≤–æ—Ä—é—î–º–æ —Ñ–∞–π–ª –ø—Ä–æ–µ–∫—Ç—É
    let project_file = format!(r#"[–ø—Ä–æ–µ–∫—Ç]
–Ω–∞–∑–≤–∞ = "{}"
–≤–µ—Ä—Å—ñ—è = "0.1.0"
—Ç–∏–ø = "{}"

[–∑–∞–ª–µ–∂–Ω–æ—Å—Ç—ñ]
"#, name, project_type);
    
    std::fs::write(format!("{}/–ø—Ä–æ–µ–∫—Ç.toml", name), project_file)?;
    
    println!("‚úì –ü—Ä–æ–µ–∫—Ç '{}' —Å—Ç–≤–æ—Ä–µ–Ω–æ", name);
    Ok(())
}

fn build_project(mode: String) -> Result<()> {
    // –ß–∏—Ç–∞—î–º–æ —Ñ–∞–π–ª –ø—Ä–æ–µ–∫—Ç—É
    let project_file = std::fs::read_to_string("–ø—Ä–æ–µ–∫—Ç.toml")?;
    
    // TODO: –Ü–º–ø–ª–µ–º–µ–Ω—Ç—É–≤–∞—Ç–∏ –ø–æ–≤–Ω—É –∑–±—ñ—Ä–∫—É –ø—Ä–æ–µ–∫—Ç—É
    println!("–ó–±—ñ—Ä–∫–∞ –ø—Ä–æ–µ–∫—Ç—É —É —Ä–µ–∂–∏–º—ñ '{}'...", mode);
    
    Ok(())
}

fn format_files(files: Vec<PathBuf>) -> Result<()> {
    for file in files {
        let source = std::fs::read_to_string(&file)?;
        // TODO: –Ü–º–ø–ª–µ–º–µ–Ω—Ç—É–≤–∞—Ç–∏ —Ñ–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è
        println!("–§–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è —Ñ–∞–π–ª—É {:?} —â–µ –≤ —Ä–æ–∑—Ä–æ–±—Ü—ñ...", file);
    }
    Ok(())
}
