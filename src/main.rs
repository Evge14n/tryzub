// –ú–æ–≤–∞ –ø—Ä–æ–≥—Ä–∞–º—É–≤–∞–Ω–Ω—è –¢—Ä–∏–∑—É–±
// –ê–≤—Ç–æ—Ä: –ú–∞—Ä—Ç–∏–Ω—é–∫ –Ñ–≤–≥–µ–Ω
// –°—Ç–≤–æ—Ä–µ–Ω–æ: 06.04.2025
// Copyright (c) 2025 –ú–∞—Ä—Ç–∏–Ω—é–∫ –Ñ–≤–≥–µ–Ω. –í—Å—ñ –ø—Ä–∞–≤–∞ –∑–∞—Ö–∏—â–µ–Ω—ñ.
// –õ—ñ—Ü–µ–Ω–∑—ñ—è: MIT

use clap::{Parser, Subcommand};
use anyhow::Result;
use std::path::PathBuf;
use std::fs;

mod lexer;
mod parser;
mod compiler;
mod vm;
mod runtime;

#[derive(Parser)]
#[command(name = "tryzub")]
#[command(author = "–ú–∞—Ä—Ç–∏–Ω—é–∫ –Ñ–≤–≥–µ–Ω <evgenmart@gmail.com>")]
#[command(version = "1.0.0")]
#[command(about = "–¢—Ä–∏–∑—É–± - –Ω–∞–π—à–≤–∏–¥—à–∞ —É–∫—Ä–∞—ó–Ω–æ–º–æ–≤–Ω–∞ –º–æ–≤–∞ –ø—Ä–æ–≥—Ä–∞–º—É–≤–∞–Ω–Ω—è", long_about = None)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// –ö–æ–º–ø—ñ–ª—é–≤–∞—Ç–∏ —Ñ–∞–π–ª —É –≤–∏–∫–æ–Ω—É–≤–∞–Ω–∏–π —Ñ–∞–π–ª
    –ö–æ–º–ø—ñ–ª—é–≤–∞—Ç–∏ {
        /// –í—Ö—ñ–¥–Ω–∏–π —Ñ–∞–π–ª .—Ç—Ä–∏–∑—É–±
        #[arg(value_name = "–§–ê–ô–õ")]
        –≤—Ö—ñ–¥: PathBuf,
        
        /// –í–∏—Ö—ñ–¥–Ω–∏–π —Ñ–∞–π–ª
        #[arg(short = '–≤', long = "–≤–∏—Ö—ñ–¥")]
        –≤–∏—Ö—ñ–¥: Option<PathBuf>,
        
        /// –†—ñ–≤–µ–Ω—å –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—ó (0-3)
        #[arg(short = '–û', long = "–æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è", default_value = "2")]
        –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è: u8,
        
        /// –¶—ñ–ª—å–æ–≤–∞ –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞
        #[arg(short = '—Ü', long = "—Ü—ñ–ª—å")]
        —Ü—ñ–ª—å: Option<String>,
    },
    
    /// –ó–∞–ø—É—Å—Ç–∏—Ç–∏ —Ñ–∞–π–ª –±–µ–∑ –∫–æ–º–ø—ñ–ª—è—Ü—ñ—ó
    –ó–∞–ø—É—Å—Ç–∏—Ç–∏ {
        /// –§–∞–π–ª –¥–ª—è –∑–∞–ø—É—Å–∫—É
        #[arg(value_name = "–§–ê–ô–õ")]
        —Ñ–∞–π–ª: PathBuf,
        
        /// –ê—Ä–≥—É–º–µ–Ω—Ç–∏ –ø—Ä–æ–≥—Ä–∞–º–∏
        #[arg(trailing_var_arg = true)]
        –∞—Ä–≥—É–º–µ–Ω—Ç–∏: Vec<String>,
    },
    
    /// –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å —Ñ–∞–π–ª—É
    –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ {
        /// –§–∞–π–ª –¥–ª—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏
        #[arg(value_name = "–§–ê–ô–õ")]
        —Ñ–∞–π–ª: PathBuf,
    },
    
    /// –°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–æ–≤–∏–π –ø—Ä–æ–µ–∫—Ç
    –ù–æ–≤–∏–π {
        /// –ù–∞–∑–≤–∞ –ø—Ä–æ–µ–∫—Ç—É
        –Ω–∞–∑–≤–∞: String,
        
        /// –¢–∏–ø –ø—Ä–æ–µ–∫—Ç—É
        #[arg(short = '—Ç', long = "—Ç–∏–ø", default_value = "–ø—Ä–æ–≥—Ä–∞–º–∞")]
        —Ç–∏–ø_–ø—Ä–æ–µ–∫—Ç—É: String,
    },
    
    /// –ó—ñ–±—Ä–∞—Ç–∏ –ø—Ä–æ–µ–∫—Ç
    –ó—ñ–±—Ä–∞—Ç–∏ {
        /// –†–µ–∂–∏–º –∑–±—ñ—Ä–∫–∏
        #[arg(short = '—Ä', long = "—Ä–µ–∂–∏–º", default_value = "–≤–∏–ø—É—Å–∫")]
        —Ä–µ–∂–∏–º: String,
    },
    
    /// –§–æ—Ä–º–∞—Ç—É–≤–∞—Ç–∏ –∫–æ–¥
    –§–æ—Ä–º–∞—Ç—É–≤–∞—Ç–∏ {
        /// –§–∞–π–ª–∏ –¥–ª—è —Ñ–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è
        —Ñ–∞–π–ª–∏: Vec<PathBuf>,
    },
}

#[global_allocator]
static GLOBAL: mimalloc::MiMalloc = mimalloc::MiMalloc;

fn main() -> Result<()> {
    env_logger::init();
    
    let cli = Cli::parse();
    
    match cli.command {
        Commands::–ö–æ–º–ø—ñ–ª—é–≤–∞—Ç–∏ { –≤—Ö—ñ–¥, –≤–∏—Ö—ñ–¥, –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è, —Ü—ñ–ª—å } => {
            println!("üî® –ö–æ–º–ø—ñ–ª—é—é —Ñ–∞–π–ª: {:?}", –≤—Ö—ñ–¥);
            compile_file(–≤—Ö—ñ–¥, –≤–∏—Ö—ñ–¥, –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è, —Ü—ñ–ª—å)?;
        }
        Commands::–ó–∞–ø—É—Å—Ç–∏—Ç–∏ { —Ñ–∞–π–ª, –∞—Ä–≥—É–º–µ–Ω—Ç–∏ } => {
            run_file(—Ñ–∞–π–ª, –∞—Ä–≥—É–º–µ–Ω—Ç–∏)?;
        }
        Commands::–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ { —Ñ–∞–π–ª } => {
            println!("üîç –ü–µ—Ä–µ–≤—ñ—Ä—è—é —Ñ–∞–π–ª: {:?}", —Ñ–∞–π–ª);
            check_file(—Ñ–∞–π–ª)?;
        }
        Commands::–ù–æ–≤–∏–π { –Ω–∞–∑–≤–∞, —Ç–∏–ø_–ø—Ä–æ–µ–∫—Ç—É } => {
            println!("üìÅ –°—Ç–≤–æ—Ä—é—é –Ω–æ–≤–∏–π –ø—Ä–æ–µ–∫—Ç: {}", –Ω–∞–∑–≤–∞);
            create_project(–Ω–∞–∑–≤–∞, —Ç–∏–ø_–ø—Ä–æ–µ–∫—Ç—É)?;
        }
        Commands::–ó—ñ–±—Ä–∞—Ç–∏ { —Ä–µ–∂–∏–º } => {
            println!("üèóÔ∏è –ó–±–∏—Ä–∞—é –ø—Ä–æ–µ–∫—Ç —É —Ä–µ–∂–∏–º—ñ: {}", —Ä–µ–∂–∏–º);
            build_project(—Ä–µ–∂–∏–º)?;
        }
        Commands::–§–æ—Ä–º–∞—Ç—É–≤–∞—Ç–∏ { —Ñ–∞–π–ª–∏ } => {
            println!("üé® –§–æ—Ä–º–∞—Ç—É—é {} —Ñ–∞–π–ª—ñ–≤", —Ñ–∞–π–ª–∏.len());
            format_files(—Ñ–∞–π–ª–∏)?;
        }
    }
    
    Ok(())
}

fn compile_file(input: PathBuf, output: Option<PathBuf>, opt_level: u8, target: Option<String>) -> Result<()> {
    let source = fs::read_to_string(&input)?;
    
    // –õ–µ–∫—Å–∏—á–Ω–∏–π –∞–Ω–∞–ª—ñ–∑
    println!("  ‚îú‚îÄ üìù –õ–µ–∫—Å–∏—á–Ω–∏–π –∞–Ω–∞–ª—ñ–∑...");
    let tokens = lexer::tokenize(&source)?;
    println!("  ‚îÇ  ‚îî‚îÄ ‚úì {} —Ç–æ–∫–µ–Ω—ñ–≤", tokens.len());
    
    // –°–∏–Ω—Ç–∞–∫—Å–∏—á–Ω–∏–π –∞–Ω–∞–ª—ñ–∑
    println!("  ‚îú‚îÄ üå≥ –°–∏–Ω—Ç–∞–∫—Å–∏—á–Ω–∏–π –∞–Ω–∞–ª—ñ–∑...");
    let ast = parser::parse(tokens)?;
    println!("  ‚îÇ  ‚îî‚îÄ ‚úì AST –ø–æ–±—É–¥–æ–≤–∞–Ω–æ");
    
    // –°–µ–º–∞–Ω—Ç–∏—á–Ω–∏–π –∞–Ω–∞–ª—ñ–∑ —Ç–∞ –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è
    println!("  ‚îú‚îÄ üîß –û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è (—Ä—ñ–≤–µ–Ω—å {})...", opt_level);
    let optimized_ast = compiler::optimize(ast, opt_level)?;
    println!("  ‚îÇ  ‚îî‚îÄ ‚úì –û–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω–æ");
    
    // –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è –∫–æ–¥—É
    let output_path = output.unwrap_or_else(|| {
        let mut path = input.clone();
        path.set_extension(if cfg!(windows) { "exe" } else { "" });
        path
    });
    
    println!("  ‚îú‚îÄ üéØ –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è –∫–æ–¥—É...");
    compiler::generate_executable(optimized_ast, output_path.clone(), target)?;
    println!("  ‚îÇ  ‚îî‚îÄ ‚úì –°—Ç–≤–æ—Ä–µ–Ω–æ: {:?}", output_path);
    
    println!("  ‚îî‚îÄ ‚úÖ –ö–æ–º–ø—ñ–ª—è—Ü—ñ—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —É—Å–ø—ñ—à–Ω–æ!");
    
    Ok(())
}

fn run_file(file: PathBuf, args: Vec<String>) -> Result<()> {
    let source = fs::read_to_string(&file)?;
    
    // –õ–µ–∫—Å–∏—á–Ω–∏–π –∞–Ω–∞–ª—ñ–∑
    let tokens = match lexer::tokenize(&source) {
        Ok(tokens) => tokens,
        Err(e) => {
            eprintln!("‚ùå –ü–æ–º–∏–ª–∫–∞ –ª–µ–∫—Å–∏—á–Ω–æ–≥–æ –∞–Ω–∞–ª—ñ–∑—É: {}", e);
            return Err(e.into());
        }
    };
    
    // –°–∏–Ω—Ç–∞–∫—Å–∏—á–Ω–∏–π –∞–Ω–∞–ª—ñ–∑
    let ast = match parser::parse(tokens) {
        Ok(ast) => ast,
        Err(e) => {
            eprintln!("‚ùå –ü–æ–º–∏–ª–∫–∞ —Å–∏–Ω—Ç–∞–∫—Å–∏—á–Ω–æ–≥–æ –∞–Ω–∞–ª—ñ–∑—É: {}", e);
            return Err(e.into());
        }
    };
    
    // –í–∏–∫–æ–Ω–∞–Ω–Ω—è —á–µ—Ä–µ–∑ VM
    vm::execute(ast, args)?;
    
    Ok(())
}

fn check_file(file: PathBuf) -> Result<()> {
    let source = fs::read_to_string(&file)?;
    
    // –õ–µ–∫—Å–∏—á–Ω–∏–π –∞–Ω–∞–ª—ñ–∑
    println!("  ‚îú‚îÄ üìù –õ–µ–∫—Å–∏—á–Ω–∏–π –∞–Ω–∞–ª—ñ–∑...");
    let tokens = lexer::tokenize(&source)?;
    println!("  ‚îÇ  ‚îî‚îÄ ‚úì {} —Ç–æ–∫–µ–Ω—ñ–≤", tokens.len());
    
    // –°–∏–Ω—Ç–∞–∫—Å–∏—á–Ω–∏–π –∞–Ω–∞–ª—ñ–∑
    println!("  ‚îú‚îÄ üå≥ –°–∏–Ω—Ç–∞–∫—Å–∏—á–Ω–∏–π –∞–Ω–∞–ª—ñ–∑...");
    let _ast = parser::parse(tokens)?;
    println!("  ‚îÇ  ‚îî‚îÄ ‚úì –°–∏–Ω—Ç–∞–∫—Å–∏—Å –ø—Ä–∞–≤–∏–ª—å–Ω–∏–π");
    
    println!("  ‚îî‚îÄ ‚úÖ –§–∞–π–ª —Å–∏–Ω—Ç–∞–∫—Å–∏—á–Ω–æ –ø—Ä–∞–≤–∏–ª—å–Ω–∏–π");
    Ok(())
}

fn create_project(name: String, project_type: String) -> Result<()> {
    fs::create_dir(&name)?;
    fs::create_dir(format!("{}/src", name))?;
    
    // –°—Ç–≤–æ—Ä—é—î–º–æ –æ—Å–Ω–æ–≤–Ω–∏–π —Ñ–∞–π–ª
    let main_content = match project_type.as_str() {
        "–ø—Ä–æ–≥—Ä–∞–º–∞" => {
            format!(r#"// {}
// –ê–≤—Ç–æ—Ä: [–í–∞—à–µ —ñ–º'—è]
// –°—Ç–≤–æ—Ä–µ–Ω–æ: {}

—Ñ—É–Ω–∫—Ü—ñ—è –≥–æ–ª–æ–≤–Ω–∞() {{
    –¥—Ä—É–∫("–ü—Ä–∏–≤—ñ—Ç –∑ –ø—Ä–æ–µ–∫—Ç—É {}! üá∫üá¶")
}}
"#, name, chrono::Local::now().format("%d.%m.%Y"), name)
        }
        "–±—ñ–±–ª—ñ–æ—Ç–µ–∫–∞" => {
            format!(r#"// –ë—ñ–±–ª—ñ–æ—Ç–µ–∫–∞ {}
// –ê–≤—Ç–æ—Ä: [–í–∞—à–µ —ñ–º'—è]  
// –°—Ç–≤–æ—Ä–µ–Ω–æ: {}

–º–æ–¥—É–ª—å {} {{
    –ø—É–±–ª—ñ—á–Ω–∏–π —Ñ—É–Ω–∫—Ü—ñ—è –ø—Ä–∏–≤—ñ—Ç–∞–Ω–Ω—è(—ñ–º'—è: —Ç—Ö—Ç) {{
        –¥—Ä—É–∫("–ü—Ä–∏–≤—ñ—Ç, " + —ñ–º'—è + "!")
    }}
}}
"#, name, chrono::Local::now().format("%d.%m.%Y"), name)
        }
        _ => return Err(anyhow::anyhow!("–ù–µ–≤—ñ–¥–æ–º–∏–π —Ç–∏–ø –ø—Ä–æ–µ–∫—Ç—É")),
    };
    
    fs::write(format!("{}/src/–≥–æ–ª–æ–≤–Ω–∞.—Ç—Ä–∏–∑—É–±", name), main_content)?;
    
    // –°—Ç–≤–æ—Ä—é—î–º–æ —Ñ–∞–π–ª –ø—Ä–æ–µ–∫—Ç—É
    let project_file = format!(r#"[–ø—Ä–æ–µ–∫—Ç]
–Ω–∞–∑–≤–∞ = "{}"
–≤–µ—Ä—Å—ñ—è = "0.1.0"
–∞–≤—Ç–æ—Ä = "[–í–∞—à–µ —ñ–º'—è]"
—Ç–∏–ø = "{}"

[–∑–∞–ª–µ–∂–Ω–æ—Å—Ç—ñ]
"#, name, project_type);
    
    fs::write(format!("{}/–ø—Ä–æ–µ–∫—Ç.toml", name), project_file)?;
    
    // –°—Ç–≤–æ—Ä—é—î–º–æ README
    let readme = format!(r#"# {}

–°—Ç–≤–æ—Ä–µ–Ω–æ –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é –º–æ–≤–∏ –ø—Ä–æ–≥—Ä–∞–º—É–≤–∞–Ω–Ω—è –¢—Ä–∏–∑—É–± üá∫üá¶

## –ó–∞–ø—É—Å–∫

```bash
—Ç—Ä–∏–∑—É–± –∑–∞–ø—É—Å—Ç–∏—Ç–∏ src/–≥–æ–ª–æ–≤–Ω–∞.—Ç—Ä–∏–∑—É–±
```

## –ó–±—ñ—Ä–∫–∞

```bash
—Ç—Ä–∏–∑—É–± –∑—ñ–±—Ä–∞—Ç–∏
```

## –õ—ñ—Ü–µ–Ω–∑—ñ—è

MIT
"#, name);
    
    fs::write(format!("{}/README.md", name), readme)?;
    
    println!("‚úÖ –ü—Ä–æ–µ–∫—Ç '{}' —Å—Ç–≤–æ—Ä–µ–Ω–æ", name);
    println!("üìÅ –°—Ç—Ä—É–∫—Ç—É—Ä–∞:");
    println!("   {}/", name);
    println!("   ‚îú‚îÄ‚îÄ –ø—Ä–æ–µ–∫—Ç.toml");
    println!("   ‚îú‚îÄ‚îÄ README.md");
    println!("   ‚îî‚îÄ‚îÄ src/");
    println!("       ‚îî‚îÄ‚îÄ –≥–æ–ª–æ–≤–Ω–∞.—Ç—Ä–∏–∑—É–±");
    
    Ok(())
}

fn build_project(mode: String) -> Result<()> {
    // –ß–∏—Ç–∞—î–º–æ —Ñ–∞–π–ª –ø—Ä–æ–µ–∫—Ç—É
    let project_file = fs::read_to_string("–ø—Ä–æ–µ–∫—Ç.toml")?;
    
    // TODO: –Ü–º–ø–ª–µ–º–µ–Ω—Ç—É–≤–∞—Ç–∏ –ø–æ–≤–Ω—É –∑–±—ñ—Ä–∫—É –ø—Ä–æ–µ–∫—Ç—É
    println!("üèóÔ∏è –ó–±—ñ—Ä–∫–∞ –ø—Ä–æ–µ–∫—Ç—É —É —Ä–µ–∂–∏–º—ñ '{}'...", mode);
    println!("  ‚îú‚îÄ üìñ –ß–∏—Ç–∞–Ω–Ω—è –ø—Ä–æ–µ–∫—Ç.toml");
    println!("  ‚îú‚îÄ üì¶ –ó–±—ñ—Ä–∫–∞ –∑–∞–ª–µ–∂–Ω–æ—Å—Ç–µ–π");
    println!("  ‚îú‚îÄ üî® –ö–æ–º–ø—ñ–ª—è—Ü—ñ—è –≤–∏—Ö—ñ–¥–Ω–æ–≥–æ –∫–æ–¥—É");
    println!("  ‚îî‚îÄ ‚úÖ –ó–±—ñ—Ä–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞");
    
    Ok(())
}

fn format_files(files: Vec<PathBuf>) -> Result<()> {
    for file in files {
        println!("  ‚îú‚îÄ üé® –§–æ—Ä–º–∞—Ç—É—é: {:?}", file);
        let source = fs::read_to_string(&file)?;
        let tokens = lexer::tokenize(&source)?;
        let ast = parser::parse(tokens)?;
        let formatted = parser::format_ast(ast)?;
        fs::write(&file, formatted)?;
        println!("  ‚îÇ  ‚îî‚îÄ ‚úì –í—ñ–¥—Ñ–æ—Ä–º–∞—Ç–æ–≤–∞–Ω–æ");
    }
    Ok(())
}
