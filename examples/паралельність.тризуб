// Приклад 4: Паралельне програмування
// Обчислення числа π методом Монте-Карло з використанням багатопоточності

імпорт математика
імпорт паралельність

// Функція для обчислення π в одному потоці
функція обчислити_пі_частина(кількість_точок: цл64, зерно: цл64) -> цл64 {
    математика.встановити_зерно(зерно)
    змінна точки_в_колі: цл64 = 0
    
    для (i від 0 до кількість_точок) {
        змінна x = математика.випадкове() * 2.0 - 1.0
        змінна y = математика.випадкове() * 2.0 - 1.0
        
        якщо (x * x + y * y <= 1.0) {
            точки_в_колі += 1
        }
    }
    
    повернути точки_в_колі
}

// Паралельне обчислення π
асинхронний функція паралельне_обчислення_пі(загальна_кількість: цл64, кількість_потоків: цл32) -> дрб64 {
    змінна точок_на_потік = загальна_кількість / кількість_потоків
    змінна завдання: [Майбутнє<цл64>] = []
    
    // Запускаємо паралельні завдання
    для (i від 0 до кількість_потоків) {
        змінна зерно = час_в_мілісекундах() + i * 1000
        змінна завдання_і = асинхронно {
            повернути обчислити_пі_частина(точок_на_потік, зерно)
        }
        додати(завдання, завдання_і)
    }
    
    // Чекаємо на завершення всіх завдань
    змінна загальні_точки_в_колі: цл64 = 0
    для (завдання_і в завдання) {
        загальні_точки_в_колі += чекати завдання_і
    }
    
    // Обчислюємо π
    повернути 4.0 * загальні_точки_в_колі як дрб64 / загальна_кількість як дрб64
}

// Послідовне обчислення для порівняння
функція послідовне_обчислення_пі(кількість_точок: цл64) -> дрб64 {
    повернути 4.0 * обчислити_пі_частина(кількість_точок, час_в_мілісекундах()) як дрб64 / 
           кількість_точок as дрб64
}

// Приклад з каналами для комунікації між потоками
структура РобочийПотік {
    id: цл32
    вхідний_канал: Канал<цл64>
    вихідний_канал: Канал<дрб64>
}

функція створити_робочий_потік(id: цл32) -> РобочийПотік {
    змінна вхід = новий_канал<цл64>()
    змінна вихід = новий_канал<дрб64>()
    
    // Запускаємо робочий потік
    асинхронно {
        поки (істина) {
            змінна кількість = отримати(вхід)
            якщо (кількість == 0) {
                переривати
            }
            
            змінна результат = послідовне_обчислення_пі(кількість)
            надіслати(вихід, результат)
        }
    }
    
    повернути РобочийПотік {
        id: id,
        вхідний_канал: вхід,
        вихідний_канал: вихід
    }
}

// Пул робочих потоків
структура ПулПотоків {
    потоки: [РобочийПотік]
    наступний_потік: цл32
}

реалізація ПулПотоків {
    функція новий(розмір: цл32) -> ПулПотоків {
        змінна потоки: [РобочийПотік] = []
        
        для (i від 0 до розмір) {
            додати(потоки, створити_робочий_потік(i))
        }
        
        повернути ПулПотоків {
            потоки: потоки,
            наступний_потік: 0
        }
    }
    
    функція виконати(&це, кількість_точок: цл64) -> дрб64 {
        // Вибираємо потік за принципом round-robin
        змінна потік = це.потоки[це.наступний_потік]
        це.наступний_потік = (це.наступний_потік + 1) % довжина(це.потоки)
        
        // Відправляємо завдання
        надіслати(потік.вхідний_канал, кількість_точок)
        
        // Отримуємо результат
        повернути отримати(потік.вихідний_канал)
    }
    
    функція завершити(&це) {
        для (потік в це.потоки) {
            надіслати(потік.вхідний_канал, 0)
        }
    }
}

// Приклад з мьютексами для синхронізації
структура ЛічильникЗМьютексом {
    значення: цл64
    мьютекс: Мьютекс
}

реалізація ЛічильникЗМьютексом {
    функція новий() -> ЛічильникЗМьютексом {
        повернути ЛічильникЗМьютексом {
            значення: 0,
            мьютекс: новий_мьютекс()
        }
    }
    
    функція збільшити(&це) {
        заблокувати(це.мьютекс)
        це.значення += 1
        розблокувати(це.мьютекс)
    }
    
    функція отримати(&це) -> цл64 {
        заблокувати(це.мьютекс)
        змінна результат = це.значення
        розблокувати(це.мьютекс)
        повернути результат
    }
}

// Головна функція
асинхронний функція головна() {
    друк("Паралельне обчислення числа π методом Монте-Карло")
    друк("==================================================\n")
    
    змінна кількість_точок: цл64 = 10000000
    змінна кількість_потоків = отримати_кількість_процесорів()
    
    друк("Кількість процесорів: " + ціле_в_рядок(кількість_потоків))
    друк("Загальна кількість точок: " + ціле_в_рядок(кількість_точок))
    друк("")
    
    // Послідовне обчислення
    друк("Послідовне обчислення...")
    змінна початок = час()
    змінна пі_послідовне = послідовне_обчислення_пі(кількість_точок)
    змінна час_послідовний = час() - початок
    друк("π ≈ " + дробове_в_рядок(пі_послідовне))
    друк("Час: " + дробове_в_рядок(час_послідовний) + " сек")
    друк("Похибка: " + дробове_в_рядок(математика.абс(пі_послідовне - математика.ПІ)))
    друк("")
    
    // Паралельне обчислення
    друк("Паралельне обчислення (" + ціле_в_рядок(кількість_потоків) + " потоків)...")
    початок = час()
    змінна пі_паралельне = чекати паралельне_обчислення_пі(кількість_точок, кількість_потоків)
    змінна час_паралельний = час() - початок
    друк("π ≈ " + дробове_в_рядок(пі_паралельне))
    друк("Час: " + дробове_в_рядок(час_паралельний) + " сек")
    друк("Похибка: " + дробове_в_рядок(математика.абс(пі_паралельне - математика.ПІ)))
    друк("")
    
    // Прискорення
    змінна прискорення = час_послідовний / час_паралельний
    друк("Прискорення: " + дробове_в_рядок(прискорення) + "x")
    друк("Ефективність: " + дробове_в_рядок(прискорення / кількість_потоків * 100) + "%")
    друк("")
    
    // Демонстрація пулу потоків
    друк("Демонстрація пулу потоків...")
    змінна пул = ПулПотоків.новий(4)
    
    змінна завдання_пулу: [Майбутнє<дрб64>] = []
    для (i від 0 до 10) {
        змінна завдання = асинхронно {
            повернути пул.виконати(1000000)
        }
        додати(завдання_пулу, завдання)
    }
    
    змінна сума_результатів = 0.0
    для (завдання в завдання_пулу) {
        сума_результатів += чекати завдання
    }
    
    друк("Середнє значення π з пулу: " + дробове_в_рядок(сума_результатів / 10.0))
    пул.завершити()
    
    // Демонстрація синхронізації
    друк("\nДемонстрація синхронізації з мьютексом...")
    змінна лічильник = ЛічильникЗМьютексом.новий()
    
    змінна завдання_лічильника: [Майбутнє<нічого>] = []
    для (i від 0 до кількість_потоків) {
        змінна завдання = асинхронно {
            для (j від 0 до 100000) {
                лічильник.збільшити()
            }
        }
        додати(завдання_лічильника, завдання)
    }
    
    // Чекаємо завершення всіх потоків
    для (завдання в завдання_лічильника) {
        чекати завдання
    }
    
    друк("Фінальне значення лічильника: " + ціле_в_рядок(лічильник.отримати()))
    друк("Очікуване значення: " + ціле_в_рядок(кількість_потоків * 100000))
}
